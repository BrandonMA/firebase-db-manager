{"version":3,"file":"index.js","sources":["../src/types/CollectionReference.ts","../src/models/reservedTypes/CollectionData.ts","../src/models/Document.ts","../src/models/shareDatabaseReference.ts","../src/models/reservedTypes/DatabaseReferenceHolder.ts","../src/models/Collection.ts","../src/models/SubCollection.ts","../src/index.ts","../src/models/Database.ts","../src/types/DocumentReference.ts"],"sourcesContent":["import * as firebase from 'firebase/app';\n\nexport type CollectionReference = firebase.firestore.CollectionReference<firebase.firestore.DocumentData>;\n\nexport function isCollectionReference(value: unknown): value is CollectionReference {\n    const casted = value as CollectionReference;\n    return casted.doc !== undefined;\n}\n","import { CollectionReference, IDEnabled } from '../../types';\n\nexport interface CollectionData extends IDEnabled {\n    reference: CollectionReference | null;\n    setReference: (reference: CollectionReference) => void;\n}\n\nexport function isCollectionData(value: unknown): value is CollectionData {\n    const casted = value as CollectionData;\n    return casted.setReference !== undefined;\n}\n","import { isCollectionData } from './reservedTypes/CollectionData';\nimport { IDEnabled } from '../types/IDEnabled';\nimport { CollectionHolder } from './reservedTypes/CollectionHolder';\nimport produce, { immerable } from 'immer';\nimport { DocumentReference } from '../types';\n\nexport class Document<DataType extends IDEnabled, SubCollections> implements CollectionHolder<SubCollections> {\n    collections: SubCollections;\n    data: Readonly<DataType>;\n    reference: DocumentReference;\n    [immerable] = true;\n\n    constructor(data: DataType, reference?: DocumentReference, subCollections?: SubCollections) {\n        this.data = data;\n        if (reference != null && subCollections != null) {\n            this.reference = reference;\n            this.collections = subCollections;\n            this.setReferenceToSubCollections();\n        }\n    }\n\n    setReferenceToSubCollections(): void {\n        if (this.collections != null) {\n            const values = Object.values(this.collections);\n            values.forEach((subCollection) => {\n                if (isCollectionData(subCollection)) {\n                    subCollection.setReference(this.reference.collection(subCollection.id));\n                }\n            });\n        }\n    }\n\n    id(): string {\n        return this.data.id;\n    }\n\n    modifyData(newData: Partial<DataType>): DataType {\n        return produce(this.data, (draft) => {\n            Object.assign(draft, newData);\n        });\n    }\n}\n","import * as firebase from 'firebase';\nimport { isDatabaseReferenceHolder } from './reservedTypes/DatabaseReferenceHolder';\nimport { isCollectionData } from './reservedTypes/CollectionData';\n\nexport default function shareDatabaseReference<Collections>(collections: Collections, db: firebase.firestore.Firestore): void {\n    const values = Object.values(collections);\n    values.forEach((collection) => {\n        if (isDatabaseReferenceHolder(collection) && isCollectionData(collection)) {\n            collection.db = db;\n            collection.setReference(db.collection(collection.id));\n        }\n    });\n}\n","import * as firebase from 'firebase/app';\n\nexport interface DatabaseReferenceHolder {\n    db: firebase.firestore.Firestore | null;\n}\n\nexport function isDatabaseReferenceHolder(value: unknown): value is DatabaseReferenceHolder {\n    const casted = value as DatabaseReferenceHolder;\n    return casted.db !== undefined;\n}\n","import { IDEnabled } from '../types/IDEnabled';\nimport { CollectionHolder } from './reservedTypes/CollectionHolder';\nimport { DatabaseReferenceHolder } from './reservedTypes/DatabaseReferenceHolder';\nimport { CollectionData } from './reservedTypes/CollectionData';\nimport { isCollectionReference, CollectionReference } from '../types/CollectionReference';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Document } from './Document';\nimport shareDatabaseReference from './shareDatabaseReference';\nimport produce from 'immer';\nimport { SortingPredicate } from '../types/SortingPredicate';\nimport { FilterPredicate } from '../types/FilterPredicate';\nimport { PaginationPredicate } from '../types/PaginationPredicate';\n\nexport class Collection<DataType extends IDEnabled, SubCollections>\n    implements IDEnabled, CollectionHolder<SubCollections>, DatabaseReferenceHolder, CollectionData {\n    id: string;\n    collections: SubCollections;\n    db: firebase.firestore.Firestore | null;\n    reference: CollectionReference | null;\n    private subscriptions: Array<() => void> = [];\n    private nextVisibleIndex: number;\n\n    constructor(id: string, subCollections: SubCollections) {\n        this.id = id;\n        this.db = null;\n        this.reference = null;\n        this.collections = subCollections;\n        this.nextVisibleIndex = 0;\n    }\n\n    setReference(reference: CollectionReference): void {\n        this.reference = reference;\n        if (this.db != null && this.collections != null) {\n            shareDatabaseReference(this.collections, this.db);\n        }\n    }\n\n    // Document creation\n\n    async createDocument(data: DataType, skipAwait?: boolean): Promise<Document<DataType, SubCollections>> {\n        const reference = this.getCollectionReference();\n        const id = data.id ? data.id : uuidv4();\n        const newData = produce(data, (draft) => {\n            draft.id = id;\n        });\n        const documentReference = reference.doc(id);\n        if (skipAwait) {\n            documentReference.set(newData, { merge: true });\n        } else {\n            await documentReference.set(newData, { merge: true });\n        }\n        return new Document(newData, documentReference, this.collections);\n    }\n\n    // Getting\n\n    async getDocument(id: string): Promise<Document<DataType, SubCollections>> {\n        const reference = this.getCollectionReference();\n        const documentReference = reference.doc(id);\n        const response = await documentReference.get();\n        if (response.exists) {\n            const data = response.data() as DataType;\n            return new Document(data, documentReference, this.collections);\n        } else {\n            throw Error('Document does not exist, check your id');\n        }\n    }\n\n    async get(\n        sortingPredicate?: SortingPredicate,\n        filterPredicate?: FilterPredicate,\n        paginationPredicate?: PaginationPredicate,\n        editQuery?: (reference: CollectionReference | firebase.firestore.Query) => firebase.firestore.Query\n    ): Promise<Array<Document<DataType, SubCollections>>> {\n        const reference = this.getCollectionReference();\n        const query = this.getQuery(reference, sortingPredicate, filterPredicate, paginationPredicate, editQuery);\n        const snapshot = await query.get();\n        if (!snapshot.empty) {\n            this.nextVisibleIndex += snapshot.size + 1; // Page size would be the index for the last document retreived, so add one.\n            return snapshot.docs.map((firebaseDocument) => {\n                const data = firebaseDocument.data() as DataType;\n                return new Document(data, firebaseDocument.ref, this.collections);\n            });\n        } else {\n            return [];\n        }\n    }\n\n    // Updating\n\n    async updateDocument(data: DataType): Promise<Document<DataType, SubCollections>> {\n        const reference = this.getCollectionReference();\n        const documentReference = reference.doc(data.id);\n        await documentReference.update(data);\n        return new Document(data, documentReference, this.collections);\n    }\n\n    // Deleting\n\n    async deleteDocument(id: string): Promise<void> {\n        const reference = this.getCollectionReference();\n        await reference.doc(id).delete();\n    }\n\n    // Subscribing to changes\n\n    subscribeToDocument(\n        id: string,\n        onDataChange: (document: Document<DataType, SubCollections>) => void,\n        onError: (error: Error) => void,\n        onDataDoesNotExist: () => void\n    ): () => void {\n        const reference = this.getCollectionReference();\n        const subscription = reference.doc(id).onSnapshot(\n            (snapshot) => {\n                if (snapshot.exists) {\n                    const data = snapshot.data() as DataType;\n                    const document = new Document(data, snapshot.ref, this.collections);\n                    onDataChange(document);\n                } else {\n                    onDataDoesNotExist();\n                }\n            },\n            (error) => {\n                onError(error);\n            }\n        );\n        this.subscriptions.push(subscription);\n        return subscription;\n    }\n\n    subscribe(\n        onDataChange: (documents: Array<Document<DataType, SubCollections>>) => void,\n        onError: (error: Error) => void,\n        sortingPredicate?: SortingPredicate,\n        filterPredicate?: FilterPredicate,\n        editQuery?: (reference: CollectionReference | firebase.firestore.Query) => firebase.firestore.Query\n    ): () => void {\n        const reference = this.getCollectionReference();\n        const query = this.getQuery(reference, sortingPredicate, filterPredicate, undefined, editQuery);\n        const subscription = query.onSnapshot(\n            (snapshot) => {\n                if (!snapshot.empty) {\n                    const documents = snapshot.docs.map((firebaseDocument) => {\n                        const data = firebaseDocument.data() as DataType;\n                        return new Document(data, firebaseDocument.ref, this.collections);\n                    });\n                    onDataChange(documents);\n                } else {\n                    onDataChange([]);\n                }\n            },\n            (error) => {\n                onError(error);\n            }\n        );\n        this.subscriptions.push(subscription);\n        return subscription;\n    }\n\n    // Implementation is not final, we must pass an original reference, passing a new array everytime is kind of useless.\n    subscribeWithDiffing(\n        onDataChange: (document: Map<string, Document<DataType, SubCollections>>) => void,\n        onError: (error: Error) => void,\n        sortingPredicate?: SortingPredicate,\n        filterPredicate?: FilterPredicate,\n        editQuery?: (reference: CollectionReference | firebase.firestore.Query) => firebase.firestore.Query\n    ): () => void {\n        const reference = this.getCollectionReference();\n        const query = this.getQuery(reference, sortingPredicate, filterPredicate, undefined, editQuery);\n        const subscription = query.onSnapshot(\n            (snapshot) => {\n                if (!snapshot.empty) {\n                    const map = new Map<string, Document<DataType, SubCollections>>();\n                    snapshot.docChanges().forEach((change) => {\n                        const data = change.doc.data() as DataType;\n                        switch (change.type) {\n                            case 'added':\n                            case 'modified':\n                                map.set(data.id, new Document(data, change.doc.ref, this.collections));\n                                break;\n                            case 'removed':\n                                map.delete(data.id);\n                                break;\n                        }\n                    });\n                    onDataChange(map);\n                }\n            },\n            (error) => {\n                onError(error);\n            }\n        );\n        this.subscriptions.push(subscription);\n        return subscription;\n    }\n\n    // Utility Methods\n\n    removeAllSubscriptions(): void {\n        this.subscriptions.forEach((subscription) => subscription());\n    }\n\n    resetPagination(): void {\n        this.nextVisibleIndex = 0;\n    }\n\n    private getCollectionReference(): CollectionReference {\n        if (this.reference != null && isCollectionReference(this.reference)) {\n            return this.reference;\n        } else {\n            throw Error('No reference set or is a document reference');\n        }\n    }\n\n    private getQuery(\n        reference: CollectionReference,\n        sortingPredicate?: SortingPredicate,\n        filterPredicate?: FilterPredicate,\n        paginationPredicate?: PaginationPredicate,\n        editQuery?: (reference: CollectionReference | firebase.firestore.Query) => CollectionReference | firebase.firestore.Query\n    ): CollectionReference | firebase.firestore.Query {\n        let newReference: firebase.firestore.Query | CollectionReference = reference;\n        if (sortingPredicate != null) {\n            newReference = newReference.orderBy(sortingPredicate.property, sortingPredicate.direction);\n        }\n        if (filterPredicate != null) {\n            newReference = newReference.where(filterPredicate.property, filterPredicate.direction, filterPredicate.value);\n        }\n        if (paginationPredicate != null) {\n            if (paginationPredicate.page != null) {\n                const lastIndex = paginationPredicate.pageSize * paginationPredicate.page + (paginationPredicate.page > 0 ? 1 : 0);\n                newReference = newReference.startAt(lastIndex).limit(paginationPredicate.pageSize);\n            } else {\n                newReference = newReference.startAt(this.nextVisibleIndex).limit(paginationPredicate.pageSize);\n            }\n        }\n        if (editQuery != null) {\n            newReference = editQuery(newReference);\n        }\n        return newReference;\n    }\n}\n","import { Collection } from './Collection';\nimport { IDEnabled } from '../types';\n\nexport class SubCollection<DataType extends IDEnabled, SubCollections> extends Collection<DataType, SubCollections> {}\n","import { decode, encode } from 'base-64';\n\nif (!global.btoa) {\n    global.btoa = encode;\n}\n\nif (!global.atob) {\n    global.atob = decode;\n}\n\nexport * from './models';\nexport * from './types';\n","import * as firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { CollectionHolder } from './reservedTypes/CollectionHolder';\nimport { DatabaseReferenceHolder } from './reservedTypes/DatabaseReferenceHolder';\nimport shareDatabaseReference from './shareDatabaseReference';\n\nexport class Database<Collections> implements CollectionHolder<Collections>, DatabaseReferenceHolder {\n    db: firebase.firestore.Firestore;\n    collections: Collections;\n\n    constructor(collections: Collections) {\n        this.db = firebase.firestore();\n        shareDatabaseReference(collections, this.db);\n        this.collections = collections;\n    }\n}\n","import * as firebase from 'firebase/app';\n\nexport type DocumentReference = firebase.firestore.DocumentReference<firebase.firestore.DocumentData>;\n\nexport function isDocumentReference(value: unknown): value is DocumentReference {\n    const casted = value as DocumentReference;\n    return casted.collection !== undefined;\n}\n"],"names":["isCollectionReference","value","undefined","doc","isCollectionData","setReference","Document","data","reference","subCollections","this","collections","setReferenceToSubCollections","Object","values","forEach","subCollection","_this","collection","id","modifyData","newData","produce","draft","assign","shareDatabaseReference","db","immerable","Collection","nextVisibleIndex","createDocument","skipAwait","documentReference","_this2","getCollectionReference","uuidv4","set","merge","getDocument","_this4","get","response","exists","Error","sortingPredicate","filterPredicate","paginationPredicate","editQuery","_this6","query","getQuery","snapshot","empty","size","docs","map","firebaseDocument","ref","updateDocument","_this8","update","deleteDocument","subscribeToDocument","onDataChange","onError","onDataDoesNotExist","subscription","onSnapshot","document","_this11","error","subscriptions","push","subscribe","documents","_this12","subscribeWithDiffing","Map","docChanges","change","type","_this13","removeAllSubscriptions","resetPagination","newReference","orderBy","property","direction","where","page","startAt","pageSize","limit","SubCollection","global","btoa","encode","atob","decode","firebase"],"mappings":"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"}